### <a name="section7">7. 結論</a>

私たちは、これまでの Haskell のアプローチを表現性において包み込む拡張可能作用の新しいフレームワークを提示した。私たちのシステムの主な見所は、

* 任意の作用を実行する計算の簡単な合成。型システムはそれぞれの計算から作用を集めてより大きい和を作る。

* クライアントとハンドラの間のやり取りから生じる作用。ハンドラは、一つの作用か、いくつか交替 (interleave) する可能性のある作用を提供することを選べる。

* 完全にハンドルされた作用は型から取り除かれて、より少ない作用を持つ計算が残る。残りの作用は、さらにほかの作用と合成したり、ハンドルしたりできる。

私たちは、拡張可能作用のフレームワークが MTL を含むということを実証した――作用のある MTL の計算は私たちのフレームワークで本質的に同じ構文で再び書けるし、私たちはモナド変換子を使うと扱いにくかったり不可能だったりしたコードを書くこともできる。さらに、私たちは**柔軟な効率性**を得た。層の動的な順序は一つのモナドによって持たれていて、特定の作用を使わない計算の一部分は、その作用のための対価を払わない（つまりそれぞれの作用は「使用分だけ払う」のだ）。

将来の仕事への道がいくつか自然に開けている。

* `IO` モナドのような「大きい」モナドを分割して、計算に足したり引いたりできるいくつかの区切られたセクションにすること。この分割は、`IORef`、`IO` の例外、時間関数、純粋な読み出し、そして読み書きを含む。

* `ST` のような作用を実装し、状態を明示し、モナディックな領域を使うアロケーションシステムをユーザーに提供すること。

* `shift`、`prompt`、制御 (control) のある限定制御のインターフェース、あるいは似たような演算子のコレクションを提供すること。

* `Eff`（継続）モナドを Haskell に（`IO` や `ST` のように）ネイティブに含めて実装を整理すること。そうすれば、**効率的な**ネイティブの状態、IO、継続、そしてそれらからほかの作用を導き出すユーザーのメカニズムを提供する言語である `Scheme` と `ML` ファミリーの元に一周まわって戻ってくるだろう。ここでの利点は、これらのユーザーが定義したシステムを追跡する型システムを持つことができることである。
